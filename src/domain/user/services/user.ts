import { IUserRepository } from '../repositories/user';
import { UserPaymentProvider } from './payment';
import { Jwt } from '../../../common/services/secure/jwt';
import { PasswordHashing } from '../../../common/services/secure/password';
import { PaymentProvider } from '../../../common/services/payment/paymentProvider';

interface Account {
  login(
    email: string,
    password: string,
  ): Promise<{
    success: boolean;
    error?: string;
    token?: string;
  }>;
  signUp(
    email: string,
    password: string,
  ): Promise<{
    success: boolean;
    error?: string;
  }>;
}

interface CanWorkWithPayment {
  topUp(
    paymentProvider: PaymentProvider,
    userId: number,
    amount: number,
  ): Promise<{
    success: boolean;
    error?: string;
  }>;
  withdraw(
    paymentProvider: PaymentProvider,
    userId: number,
    amount: number,
  ): Promise<{
    success: boolean;
    error?: string;
  }>;
}

interface UserService extends CanWorkWithPayment, Account {
  getProfile(userId: number): Promise<{
    success: boolean;
    user?: {
      email: string | null;
      nickname: string | null;
      ballance: number | null;
      rank: number | null;
      verified: boolean | null;
    };
  }>;
  updateProfile(
    email: string,
    password?: string,
    nickname?: string,
  ): Promise<{
    success: boolean;
  }>;
}

class User implements UserService {
  #jwtService: Jwt;
  #passwordService: PasswordHashing;
  #paymentService: UserPaymentProvider;
  #userRepository: IUserRepository;

  constructor(
    jwtService: Jwt,
    passwordService: PasswordHashing,
    paymentService: UserPaymentProvider,
    userRepository: IUserRepository,
  ) {
    this.#jwtService = jwtService;
    this.#passwordService = passwordService;
    this.#paymentService = paymentService;
    this.#userRepository = userRepository;
  }

  login = async (email: string, password: string) => {
    const user = await this.#userRepository.getByEmail(email);

    if (!user) {
      return { success: false, error: 'Invalid email or password' };
    }

    const isValid = await this.#passwordService.verify(user.password, password);

    if (!isValid) {
      return { success: false, error: 'Invalid email or password' };
    }

    const token = this.#jwtService.sign({
      user_id: user.user_id,
      email: user.email,
      deactivated: user.deactivated,
    });

    return { success: true, token };
  };

  signUp = async (email: string, password: string) => {
    try {
      const hashedPassword = await this.#passwordService.hash(password);
      const autoGeneratedNickName = 'user-' + Math.random().toString().slice(2);

      return this.#userRepository.create({
        email,
        password: hashedPassword,
        nickname: autoGeneratedNickName,
        ballance: 0,
        deactivated: false,
        verified: false,
        rank: 0,
        created_at: new Date(),
        updated_at: new Date(),
      });
    } catch (err: any) {
      return { success: false, error: 'Failed to create new user' };
    }
  };

  getProfile = async (userId: number) => {
    try {
      const user = await this.#userRepository.getById(userId);

      if (!user) {
        return { success: false };
      }

      return {
        success: true,
        user: {
          email: user.email,
          nickname: user.nickname,
          ballance: user.ballance,
          rank: user.rank,
          verified: user.verified,
        },
      };
    } catch (err) {
      console.error(err);
      return { success: false };
    }
  };

  updateProfile = async (email: string, password: string, nickname: string) => {
    try {
      const updatedObject: {
        email: string;
        password?: string;
        nickname?: string;
      } = {
        email,
      };
      if (password) {
        updatedObject.password = await this.#passwordService.hash(password);
      }
      if (nickname) {
        updatedObject.nickname = nickname;
      }

      this.#userRepository.update(updatedObject);

      return { success: true };
    } catch (err) {
      console.error('updateProfile Error', err);
      return { success: false };
    }
  };

  topUp = async (
    paymentProvider: PaymentProvider,
    userId: number,
    amount: number,
  ) => {
    try {
      this.#paymentService.setPaymentProvider(paymentProvider);
      return this.#paymentService.topUp(userId, amount);
    } catch (err) {
      console.error(err);
      return { success: false, error: 'Failed to top-up' };
    }
  };

  withdraw = async (
    paymentProvider: PaymentProvider,
    userId: number,
    amount: number,
  ) => {
    try {
      this.#paymentService.setPaymentProvider(paymentProvider);
      const res = await this.#paymentService.withdraw(userId, amount);
      return res;
    } catch (err) {
      console.error(err);
      return { success: false, error: 'Failed to withdraw' };
    }
  };
}

export { User };
export type { Account, UserService };
